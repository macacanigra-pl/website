var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Learn to program is a breeze!","text":"<p>Understandable</p> <p>The keyword is a whole word in English, not an abbreviation.</p> <ul> <li> <p> Easy to Learn!</p> <p> Just drag 'n drop, then attach or detach the block.</p> </li> <li> <p> Reactive Environment</p> <p> Reactive means action and reaction. When user makes any changes , MNL will response it with the result of evaluation or error if any.</p> </li> <li> <p> Shape and Color</p> <p> Assisting users by utilizing visual language capabilities: shapes and colors. Shapes will represent grammar, while colors will indicate value types.</p> </li> <li> <p> Type Inference</p> <p> Users do not need to declare the type explicitly! Let MNL do it for them (implicit typing).</p> </li> <li> <p> Program Visualization</p> <p> Show the beta reduction and the function value visually.</p> </li> <li> <p> It's a Functional PL</p> <p> MNL is a pure block-based functional programming language.</p> </li> <li> <p> YAKI</p> <p> MNL proudly presents a compiler, the Yet Another K/C Compiler Interface (YAKI). This powerful tool seamlessly transforms intuitive block-based programming languages into text-based languages like SML and Scala.</p> </li> <li> <p> Typing Rule</p> <p> Another YAKI capability is writing the typing derivation of MNL.</p> </li> <li> <p> Typing Suggestion</p> <p> MNL will elegantly present a suggested term type in a color box, thoughtfully aligned with its type constraints.</p> </li> </ul>"},{"location":"about.html","title":"About","text":"<p>Macaca Nigra Language (MNL) is a block-based functional programming language designed to help users learn programming. It allows users to visualize all processes, such as beta reduction and function value. The language also uses visual capabilities such as shape and color to convey meaning to the user.</p> <p>However, it still needs improvement in certain areas to function effectively. These include enhancing the advanced circularity check (occurrence check) in type inference, optimizing memory usage for tail functions, and refining the continuation-passing style.</p>"}]}